import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow, TableCaption } from '@/components/ui/table';
import { BarChartHorizontalBig, Download, Loader2, Users, PieChart, BarChart2, Activity, Search, UserCog, Clock, CheckCircle2, XCircle } from 'lucide-react';
import { motion } from 'framer-motion';
import { useToast } from '@/components/ui/use-toast';
import { parseISO, getMonth, format, getYear, startOfDay, endOfDay, subDays, startOfWeek, endOfWeek, startOfMonth, endOfMonth, startOfYear, endOfYear, subMonths, differenceInHours, differenceInMinutes } from 'date-fns';
import { fr } from 'date-fns/locale';
import { supabase } from '@/lib/supabaseClient';

const StatsChart = ({ data, type, title, isLoading }) => {
  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-40">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }
  if (!data || data.length === 0) {
    return <p className="text-muted-foreground text-center py-4">Aucune donnée pour ce graphique.</p>;
  }

  const ChartComponent = () => {
    if (type === 'bar') {
      const maxValue = Math.max(...data.map(d => d.value), 0);
      return (
        <div className="space-y-2">
          {data.map((item, index) => (
            <div key={index} className="flex items-center">
              <div className="w-1/3 text-sm truncate pr-2 text-foreground">{item.label}</div>
              <div className="w-2/3 bg-muted rounded-full h-6">
                <motion.div
                  className="bg-primary h-6 rounded-full text-xs text-primary-foreground flex items-center justify-end pr-2"
                  initial={{ width: 0 }}
                  animate={{ width: `${maxValue > 0 ? (item.value / maxValue) * 100 : 0}%` }}
                  transition={{ duration: 0.5, delay: index * 0.1 }}
                >
                  {item.value.toFixed(2)}
                </motion.div>
              </div>
            </div>
          ))}
        </div>
      );
    } else if (type === 'pie') {
      const total = data.reduce((sum, item) => sum + item.value, 0);
      if (total === 0) return <p className="text-muted-foreground text-center py-4">Total est zéro, impossible d'afficher le camembert.</p>;
      const colors = ['#0ea5e9', '#22c55e', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899']; 

      return (
        <div className="flex flex-col items-center space-y-4">
          <div className="w-32 h-32 rounded-full relative" style={{
            background: `conic-gradient(${data.map((item, index) => `${colors[index % colors.length]} ${(data.slice(0, index).reduce((acc, curr) => acc + (curr.value / total) * 360, 0))}deg ${(data.slice(0, index + 1).reduce((acc, curr) => acc + (curr.value / total) * 360, 0))}deg`).join(', ')})`
          }}>
          </div>
          <ul className="text-xs space-y-1 w-full max-w-xs text-foreground">
            {data.map((item, index) => (
              <li key={index} className="flex items-center justify-between">
                <div className="flex items-center">
                  <span className={`w-3 h-3 rounded-sm mr-2`} style={{ backgroundColor: colors[index % colors.length] }}></span>
                  {item.label}
                </div>
                <span>{item.value} ({((item.value / total) * 100).toFixed(1)}%)</span>
              </li>
            ))}
          </ul>
        </div>
      );
    }
    return null;
  };

  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle className="text-lg flex items-center">
          {type === 'bar' && <BarChart2 className="mr-2 h-5 w-5 text-primary" />}
          {type === 'pie' && <PieChart className="mr-2 h-5 w-5 text-primary" />}
          {type === 'line' && <Activity className="mr-2 h-5 w-5 text-primary" />}
          {title}
        </CardTitle>
      </CardHeader>
      <CardContent>
        <ChartComponent />
      </CardContent>
    </Card>
  );
};


const StatistiquesPage = () => {
  const { toast } = useToast();
  const [guichetieres, setGuichetieres] = useState([]);
  const [agences, setAgences] = useState([]);
  const [allPointages, setAllPointages] = useState([]);
  const [planning, setPlanning] = useState([]);
  const [appSettings, setAppSettings] = useState({ creneauxPointage: [{ debut: '09:00', fin: '19:00' }] });
  const [isLoading, setIsLoading] = useState(false);

  const [filterAgenceInput, setFilterAgenceInput] = useState('');
  const [filterPeriode, setFilterPeriode] = useState('mois'); 

  const periodeOptions = [
    { value: 'jour', label: "Aujourd'hui" },
    { value: 'hier', label: "Hier" },
    { value: 'semaine', label: "7 derniers jours" },
    { value: 'mois', label: "Ce mois-ci" },
    { value: 'mois_prec', label: "Mois précédent" },
    { value: 'annee', label: "Cette année" },
    { value: 'tout', label: "Tout" },
  ];

  // Nouvelles données pour les connexions des chefs d'agence
  const [chefsAgence, setChefsAgence] = useState([]);
  const [connexionsChefs, setConnexionsChefs] = useState([]);
  const [isLoadingChefsStats, setIsLoadingChefsStats] = useState(false);

  const fetchData = useCallback(async () => {
    setIsLoading(true);
    const { data: guichetieresData, error: guichetieresError } = await supabase.from('guichetieres').select('*');
    if (guichetieresError) toast({ title: 'Erreur Guichetières', description: guichetieresError.message, variant: 'destructive' });
    else setGuichetieres(guichetieresData || []);

    const { data: agencesData, error: agencesError } = await supabase.from('agences').select('*');
    if (agencesError) toast({ title: 'Erreur Agences', description: agencesError.message, variant: 'destructive' });
    else setAgences(agencesData || []);

    const { data: pointagesData, error: pointagesError } = await supabase.from('pointages').select('*');
    if (pointagesError) toast({ title: 'Erreur Pointages', description: pointagesError.message, variant: 'destructive' });
    else setAllPointages(pointagesData || []);

    const { data: planningData, error: planningError } = await supabase.from('planning').select('*');
    if (planningError) toast({ title: 'Erreur Planning', description: planningError.message, variant: 'destructive' });
    else setPlanning(planningData || []);

    const { data: settingsData, error: settingsError } = await supabase.from('app_settings').select('value').eq('key', 'general').single();
    if (settingsError && settingsError.code !== 'PGRST116') toast({ title: 'Erreur Paramètres', description: settingsError.message, variant: 'destructive' });
    else if (settingsData) setAppSettings(settingsData.value || { creneauxPointage: [{ debut: '09:00', fin: '19:00' }] });
    
    // Chargement des données des chefs d'agence et leurs connexions
    await fetchChefsAgenceData();
    
    setIsLoading(false);
  }, [toast]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const getDateRangeForFilter = (filter) => {
    const now = new Date();
    switch (filter) {
      case 'jour': return { start: startOfDay(now), end: endOfDay(now) };
      case 'hier': 
        const yesterday = subDays(now, 1);
        return { start: startOfDay(yesterday), end: endOfDay(yesterday) };
      case 'semaine': return { start: startOfDay(subDays(now, 6)), end: endOfDay(now) }; 
      case 'mois': return { start: startOfMonth(now), end: endOfMonth(now) };
      case 'mois_prec':
        const prevMonth = subMonths(now, 1);
        return { start: startOfMonth(prevMonth), end: endOfMonth(prevMonth) };
      case 'annee': return { start: startOfYear(now), end: endOfYear(now) };
      case 'tout': return { start: null, end: null }; 
      default: return { start: startOfMonth(now), end: endOfMonth(now) };
    }
  };

  const statsData = useMemo(() => {
    const nombrePointagesRequis = appSettings.creneauxPointage?.length || 1;
    const { start: filterStartDate, end: filterEndDate } = getDateRangeForFilter(filterPeriode);

    return guichetieres
      .filter(g => filterAgenceInput === '' || (g.agenceAssigne && g.agenceAssigne.toLowerCase().includes(filterAgenceInput.toLowerCase())))
      .map(g => {
        const pointagesGuichetiere = allPointages.filter(pt => {
          const ptDate = parseISO(pt.date);
          const isInDateRange = filterStartDate && filterEndDate ? (ptDate >= filterStartDate && ptDate <= filterEndDate) : true;
          return pt.guichetiereMatricule === g.matricule && isInDateRange;
        });
        
        const joursPlanifies = planning.filter(p => {
          const pDate = parseISO(p.date);
          const isInDateRange = filterStartDate && filterEndDate ? (pDate >= filterStartDate && pDate <= filterEndDate) : true;
          return p.guichetiereId === g.id && p.agenceNom === g.agenceAssigne && isInDateRange;
        }).length; 

        const joursTravailles = [...new Set(pointagesGuichetiere.map(p => p.date))].length;
        const joursSup = Math.max(0, joursTravailles - joursPlanifies);
        
        // Calcul des jours de remplacement
        const joursRemplacee = planning.filter(p => {
          const pDate = parseISO(p.date);
          const isInDateRange = filterStartDate && filterEndDate ? (pDate >= filterStartDate && pDate <= filterEndDate) : true;
          return p.guichetiereId === g.id && p.remplacement === true && p.estRemplacee === true && isInDateRange;
        }).length;
        
        const joursRemplacante = planning.filter(p => {
          const pDate = parseISO(p.date);
          const isInDateRange = filterStartDate && filterEndDate ? (pDate >= filterStartDate && pDate <= filterEndDate) : true;
          return p.guichetiereId === g.id && p.remplacement === true && p.estRemplacante === true && isInDateRange;
        }).length;
        
        const totalPointagesAttendusJoursPlanifies = joursPlanifies * nombrePointagesRequis;
        const totalPointagesAttendusJoursTravailles = joursTravailles * nombrePointagesRequis;
        const pointagesEffectues = pointagesGuichetiere.length;
        
        // Taux basé sur les jours travaillés (pas sur les jours planifiés)
        const tauxPointage = totalPointagesAttendusJoursTravailles > 0 ? Math.min(100, (pointagesEffectues / totalPointagesAttendusJoursTravailles) * 100) : (pointagesEffectues > 0 ? 100 : 0);

        return {
          id: g.id,
          nom: `${g.nom} ${g.prenom}`,
          agence: g.agenceAssigne || 'N/A',
          joursPlanifies,
          joursTravailles,
          joursSup,
          joursRemplacee,
          joursRemplacante,
          tauxPointage: tauxPointage,
          pointagesEffectues,
          totalPointagesAttendus: totalPointagesAttendusJoursTravailles // Utilisation du nombre attendu pour les jours travaillés
        };
      });
  }, [guichetieres, planning, allPointages, filterAgenceInput, filterPeriode, appSettings.creneauxPointage]);

  const chartDataAgenceTauxPointage = useMemo(() => {
    const dataByAgence = agences.map(agence => {
      const guichetieresDeLAgence = statsData.filter(stat => stat.agence === agence.nom);
      if (guichetieresDeLAgence.length === 0) return null;
      const totalTaux = guichetieresDeLAgence.reduce((sum, stat) => sum + stat.tauxPointage, 0);
      return { label: agence.nom, value: guichetieresDeLAgence.length > 0 ? (totalTaux / guichetieresDeLAgence.length) : 0 };
    }).filter(Boolean);
    return dataByAgence.sort((a,b) => b.value - a.value).slice(0,5); 
  }, [statsData, agences]);

  const chartDataPresence = useMemo(() => {
    const totalJoursPlanifies = statsData.reduce((sum, stat) => sum + stat.joursPlanifies, 0);
    const totalJoursTravailles = statsData.reduce((sum, stat) => sum + stat.joursTravailles, 0);
    const totalJoursSup = statsData.reduce((sum, stat) => sum + stat.joursSup, 0);
    return [
      { label: 'Jours Planifiés', value: totalJoursPlanifies },
      { label: 'Jours Travaillés Effectifs', value: totalJoursTravailles - totalJoursSup },
      { label: 'Jours Supplémentaires', value: totalJoursSup },
    ].filter(d => d.value > 0);
  }, [statsData]);


  const handleExport = () => {
    const dataToExport = statsData.map(({ id, ...rest }) => ({...rest, tauxPointage: rest.tauxPointage.toFixed(2)})); 
    const csvHeader = "Guichetiere,Agence,JoursPlanifies,JoursTravailles,JoursSup,JoursRemplacee,JoursRemplacante,PointagesEffectues,PointagesAttendusJoursTravailles,TauxPointage\n";
    const csvRows = dataToExport.map(row => 
      `${row.nom},${row.agence},${row.joursPlanifies},${row.joursTravailles},${row.joursSup},${row.joursRemplacee},${row.joursRemplacante},${row.pointagesEffectues},${row.totalPointagesAttendus},${row.tauxPointage}`
    ).join("\n");
    const csvString = `${csvHeader}${csvRows}`;
    
    const dataStr = `data:text/csv;charset=utf-8,${encodeURIComponent(csvString)}`;
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute('href', dataStr);
    downloadAnchorNode.setAttribute('download', 'statistiques_pointage.csv');
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
    toast({
      title: "Exportation réussie",
      description: "Les statistiques ont été exportées au format CSV.",
      className: "bg-green-500 text-white"
    });
  };
  
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 },
  };

  // Fonction pour charger les données des chefs d'agence et leurs connexions
  const fetchChefsAgenceData = async () => {
    setIsLoadingChefsStats(true);
    
    // Récupérer la liste des chefs d'agence
    const { data: chefsData, error: chefsError } = await supabase
      .from('chefs_agence')
      .select('*')
      .order('nom', { ascending: true });
      
    if (chefsError) {
      toast({ title: "Erreur chefs d'agence", description: chefsError.message, variant: "destructive" });
    } else {
      setChefsAgence(chefsData || []);
    }
    
    // Récupérer les connexions des chefs d'agence
    const { data: connexionsData, error: connexionsError } = await supabase
      .from('connexions_chefs')
      .select('*')
      .order('date_connexion', { ascending: false });
    
    if (connexionsError) {
      toast({ title: "Erreur connexions", description: connexionsError.message, variant: "destructive" });
    } else {
      setConnexionsChefs(connexionsData || []);
    }
    
    setIsLoadingChefsStats(false);
  };
  
  // Calcul des statistiques de connexion pour les chefs d'agence
  const chefAgenceStatsData = useMemo(() => {
    const { start: filterStartDate, end: filterEndDate } = getDateRangeForFilter(filterPeriode);
    
    return chefsAgence
      .filter(chef => filterAgenceInput === '' || 
        (chef.agenceEnCharge && chef.agenceEnCharge.toLowerCase().includes(filterAgenceInput.toLowerCase())))
      .map(chef => {
        // Récupérer toutes les connexions de ce chef dans la période
        const connexionsDuChef = connexionsChefs.filter(conn => {
          const connDate = parseISO(conn.date_connexion);
          const isInDateRange = filterStartDate && filterEndDate 
            ? (connDate >= filterStartDate && connDate <= filterEndDate) 
            : true;
          return conn.chef_agence_id === chef.id && isInDateRange;
        });
        
        // Trier les connexions par date
        const connexionsTriees = [...connexionsDuChef].sort((a, b) => 
          parseISO(a.date_connexion) - parseISO(b.date_connexion));
        
        // Dernière connexion
        const derniereConnexion = connexionsTriees.length > 0 
          ? connexionsTriees[connexionsTriees.length - 1] 
          : null;

        // Dernière déconnexion 
        const derniereDeconnexion = derniereConnexion && derniereConnexion.date_deconnexion
          ? format(parseISO(derniereConnexion.date_deconnexion), 'dd/MM/yyyy HH:mm')
          : derniereConnexion && !derniereConnexion.date_deconnexion
          ? 'En cours'
          : 'Jamais';
        
        // Heures de travail standard (8h par jour)
        const heuresTravailStandard = 8;
        
        // Calcul du temps total connecté (en heures)
        let tempsTotalConnexion = 0;
        
        connexionsTriees.forEach(conn => {
          if (conn.date_deconnexion) {
            const dateConnexion = parseISO(conn.date_connexion);
            const dateDeconnexion = parseISO(conn.date_deconnexion);
            const dureeEnMinutes = differenceInMinutes(dateDeconnexion, dateConnexion);
            tempsTotalConnexion += dureeEnMinutes / 60; // Conversion en heures
          }
        });
        
        // Nombre de jours de la période pour calculer le temps de travail attendu
        let joursAttendus = 0;
        if (filterStartDate && filterEndDate) {
          // Calculer le nombre de jours ouvrés (lundi-vendredi) dans la période
          let currentDate = new Date(filterStartDate);
          while (currentDate <= filterEndDate) {
            const dayOfWeek = currentDate.getDay();
            if (dayOfWeek !== 0 && dayOfWeek !== 6) { // 0 = dimanche, 6 = samedi
              joursAttendus++;
            }
            currentDate.setDate(currentDate.getDate() + 1);
          }
        } else {
          // Si pas de période définie, prendre le mois courant par défaut
          joursAttendus = 22; // Moyenne de jours ouvrés par mois
        }
        
        // Temps de travail attendu en heures
        const tempsAttendus = joursAttendus * heuresTravailStandard;
        
        // Calcul du taux de conformité (%)
        const tauxConformite = tempsAttendus > 0 
          ? Math.min(100, (tempsTotalConnexion / tempsAttendus) * 100) 
          : 0;
        
        // Vérifier si le chef est actuellement connecté
        const estConnecte = derniereConnexion 
          ? !derniereConnexion.date_deconnexion 
          : false;
        
        return {
          id: chef.id,
          nom: `${chef.prenom} ${chef.nom}`,
          agence: chef.agenceEnCharge || 'N/A',
          estConnecte,
          derniereConnexion: derniereConnexion ? format(parseISO(derniereConnexion.date_connexion), 'dd/MM/yyyy HH:mm') : 'Jamais',
          derniereDeconnexion: derniereDeconnexion,
          derniereDuree: derniereConnexion && derniereConnexion.date_deconnexion 
            ? `${(differenceInMinutes(parseISO(derniereConnexion.date_deconnexion), parseISO(derniereConnexion.date_connexion)) / 60).toFixed(1)}h` 
            : estConnecte ? 'En cours' : 'N/A',
          tauxConformite: tauxConformite,
          tempsTotalConnexion: `${tempsTotalConnexion.toFixed(1)}h`,
          tempsAttendus: `${tempsAttendus}h`
        };
      });
  }, [chefsAgence, connexionsChefs, filterAgenceInput, filterPeriode, getDateRangeForFilter]);
  
  // Calculate summary statistics for chefs d'agence
  const chefAgenceStats = useMemo(() => {
    const totalChefs = chefAgenceStatsData.length;
    const chefsConnectes = chefAgenceStatsData.filter(chef => chef.estConnecte).length;
    const chefsDeconnectes = totalChefs - chefsConnectes;
    
    return {
      totalChefs,
      chefsConnectes,
      chefsDeconnectes,
      pourcentageConnectes: totalChefs > 0 ? (chefsConnectes / totalChefs * 100).toFixed(0) : 0
    };
  }, [chefAgenceStatsData]);

  // Exporter les données de connexion des chefs d'agence
  const handleExportChefsStats = () => {
    const dataToExport = chefAgenceStatsData.map(chef => ({
      ...chef,
      tauxConformite: chef.tauxConformite.toFixed(2)
    }));
    
    const csvHeader = "Nom,Agence,EstConnecte,DerniereConnexion,DerniereDuree,TempsTotalConnexion,TempsAttendus,TauxConformite\n";
    const csvRows = dataToExport.map(row => 
      `${row.nom},${row.agence},${row.estConnecte ? 'Oui' : 'Non'},${row.derniereConnexion},${row.derniereDuree},${row.tempsTotalConnexion},${row.tempsAttendus},${row.tauxConformite}%`
    ).join("\n");
    
    const csvString = `${csvHeader}${csvRows}`;
    
    const dataStr = `data:text/csv;charset=utf-8,${encodeURIComponent(csvString)}`;
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute('href', dataStr);
    downloadAnchorNode.setAttribute('download', 'statistiques_connexions_chefs.csv');
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
    
    toast({
      title: "Exportation réussie",
      description: "Les statistiques des chefs d'agence ont été exportées au format CSV.",
      className: "bg-green-500 text-white"
    });
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
      className="space-y-6 p-4 md:p-6"
    >
      <Card className="shadow-xl glassmorphism">
        <CardHeader>
          <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
            <div>
              <CardTitle className="text-2xl md:text-3xl font-bold text-primary flex items-center">
                <BarChartHorizontalBig className="mr-2 md:mr-3 h-7 w-7 md:h-8 md:w-8" /> Statistiques de Pointage
              </CardTitle>
              <CardDescription className="text-sm md:text-base">
                Visualisez les performances de pointage des guichetières.
              </CardDescription>
            </div>
          </div>
          <div className="mt-4 md:mt-6 flex flex-col md:flex-row gap-3 md:gap-4">
            <div className="relative flex-grow md:max-w-xs">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 md:h-5 md:w-5 text-muted-foreground" />
              <Input 
                type="text" 
                placeholder="Filtrer par nom d'agence..." 
                value={filterAgenceInput}
                onChange={(e) => setFilterAgenceInput(e.target.value)}
                className="pl-9 md:pl-10 w-full text-sm md:text-base"
                disabled={isLoading}
              />
            </div>
            <Select value={filterPeriode} onValueChange={setFilterPeriode} disabled={isLoading}>
              <SelectTrigger className="w-full md:w-[200px] text-foreground text-sm md:text-base">
                <SelectValue placeholder="Filtrer par période" />
              </SelectTrigger>
              <SelectContent>
                {periodeOptions.map(option => (
                  <SelectItem key={option.value} value={option.value} className="text-sm md:text-base">{option.label}</SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Button variant="outline" onClick={handleExport} className="w-full md:w-auto text-sm md:text-base" disabled={isLoading || statsData.length === 0}>
              <Download className="mr-2 h-4 w-4" /> Exporter CSV
            </Button>
          </div>
        </CardHeader>
        <CardContent>
           {isLoading && (
             <div className="flex justify-center items-center h-64">
               <Loader2 className="h-10 w-10 md:h-12 md:w-12 animate-spin text-primary" />
             </div>
           )}
          {!isLoading && (
            <>
              <div className="grid md:grid-cols-2 gap-4 md:gap-6 mb-4 md:mb-6">
                <StatsChart data={chartDataAgenceTauxPointage} type="bar" title="Top 5 Agences par Taux de Pointage Moyen" isLoading={isLoading} />
                <StatsChart data={chartDataPresence} type="pie" title="Répartition des Jours de Présence" isLoading={isLoading} />
              </div>

              {statsData.length > 0 ? (
                <div className="overflow-x-auto">
                  <Table>
                    <TableCaption className="text-xs md:text-sm">Statistiques de pointage des guichetières.</TableCaption>
                    <TableHeader>
                      <TableRow>
                        <TableHead className="text-xs md:text-sm">Guichetière</TableHead>
                        <TableHead className="text-xs md:text-sm">Agence</TableHead>
                        <TableHead className="text-center text-xs md:text-sm">Jours Planifiés</TableHead>
                        <TableHead className="text-center text-xs md:text-sm">Jours Travaillés</TableHead>
                        <TableHead className="text-center text-xs md:text-sm">Jours Sup.</TableHead>
                        <TableHead className="text-center text-xs md:text-sm">Jours Remplacée</TableHead>
                        <TableHead className="text-center text-xs md:text-sm">Jours Remplaçante</TableHead>
                        <TableHead className="text-center text-xs md:text-sm">Pointages Effectués / Attendus (Jours Travaillés)</TableHead>
                        <TableHead className="text-center text-xs md:text-sm">Taux de Pointage (%)</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {statsData.map((stat, index) => (
                        <motion.tr 
                          key={stat.id}
                          variants={itemVariants}
                          initial="hidden"
                          animate="visible"
                          transition={{ delay: index * 0.05 }}
                          className="hover:bg-muted/50 dark:hover:bg-muted/20 text-xs md:text-sm"
                        >
                          <TableCell className="font-medium">{stat.nom}</TableCell>
                          <TableCell>{stat.agence}</TableCell>
                          <TableCell className="text-center">{stat.joursPlanifies}</TableCell>
                          <TableCell className="text-center">{stat.joursTravailles}</TableCell>
                          <TableCell className="text-center">{stat.joursSup}</TableCell>
                          <TableCell className="text-center">{stat.joursRemplacee}</TableCell>
                          <TableCell className="text-center">{stat.joursRemplacante}</TableCell>
                          <TableCell className="text-center">{stat.pointagesEffectues} / {stat.totalPointagesAttendus}</TableCell>
                          <TableCell className="text-center">
                            <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2 md:h-2.5 relative">
                              <div 
                                className="bg-primary h-2 md:h-2.5 rounded-full" 
                                style={{ width: `${stat.tauxPointage.toFixed(2)}%` }}
                              ></div>
                            </div>
                            {stat.tauxPointage.toFixed(2)}%
                          </TableCell>
                        </motion.tr>
                      ))}
                    </TableBody>
                  </Table>
                </div>
              ) : (
                <div className="text-center py-10 text-muted-foreground">
                  <Users className="mx-auto h-10 w-10 md:h-12 md:w-12 mb-3 md:mb-4" />
                  <p className="text-base md:text-lg">Aucune donnée statistique à afficher pour les filtres sélectionnés.</p>
                  <p className="text-xs md:text-sm">Vérifiez vos filtres ou assurez-vous que des données de pointage et de planning existent.</p>
                </div>
              )}
            </>
          )}
        </CardContent>
      </Card>

      {/* Nouvelle section pour les statistiques de connexion des chefs d'agence */}
      <Card className="shadow-xl glassmorphism">
        <CardHeader>
          <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
            <div>
              <CardTitle className="text-2xl md:text-3xl font-bold text-primary flex items-center">
                <UserCog className="mr-2 md:mr-3 h-7 w-7 md:h-8 md:w-8" /> État des Chefs d'Agence
              </CardTitle>
              <CardDescription className="text-sm md:text-base">
                Suivez l'état de connexion et les performances des chefs d'agence.
              </CardDescription>
            </div>
          </div>
          <div className="mt-4 md:mt-6 flex flex-col md:flex-row gap-3 md:gap-4">
            <div className="relative flex-grow md:max-w-xs">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 md:h-5 md:w-5 text-muted-foreground" />
              <Input 
                type="text" 
                placeholder="Filtrer par nom d'agence..." 
                value={filterAgenceInput}
                onChange={(e) => setFilterAgenceInput(e.target.value)}
                className="pl-9 md:pl-10 w-full text-sm md:text-base"
                disabled={isLoadingChefsStats}
              />
            </div>
            <Select value={filterPeriode} onValueChange={setFilterPeriode} disabled={isLoadingChefsStats}>
              <SelectTrigger className="w-full md:w-[200px] text-foreground text-sm md:text-base">
                <SelectValue placeholder="Filtrer par période" />
              </SelectTrigger>
              <SelectContent>
                {periodeOptions.map(option => (
                  <SelectItem key={option.value} value={option.value} className="text-sm md:text-base">{option.label}</SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Button 
              variant="outline" 
              onClick={handleExportChefsStats} 
              className="w-full md:w-auto text-sm md:text-base" 
              disabled={isLoadingChefsStats || chefAgenceStatsData.length === 0}
            >
              <Download className="mr-2 h-4 w-4" /> Exporter CSV
            </Button>
          </div>
        </CardHeader>
        <CardContent>
          {isLoadingChefsStats && (
            <div className="flex justify-center items-center h-64">
              <Loader2 className="h-10 w-10 md:h-12 md:w-12 animate-spin text-primary" />
            </div>
          )}
          {!isLoadingChefsStats && (
            <>
              {chefAgenceStatsData.length > 0 ? (
                <>
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <Card className="bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800">
                      <CardContent className="pt-6">
                        <div className="text-center">
                          <p className="text-sm font-medium text-blue-600 dark:text-blue-400">Total Chefs d'Agence</p>
                          <p className="text-3xl font-bold text-blue-700 dark:text-blue-300">{chefAgenceStats.totalChefs}</p>
                        </div>
                      </CardContent>
                    </Card>
                    
                    <Card className="bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800">
                      <CardContent className="pt-6">
                        <div className="text-center">
                          <p className="text-sm font-medium text-green-600 dark:text-green-400">Connectés</p>
                          <p className="text-3xl font-bold text-green-700 dark:text-green-300">{chefAgenceStats.chefsConnectes}</p>
                        </div>
                      </CardContent>
                    </Card>
                    
                    <Card className="bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800">
                      <CardContent className="pt-6">
                        <div className="text-center">
                          <p className="text-sm font-medium text-red-600 dark:text-red-400">Déconnectés</p>
                          <p className="text-3xl font-bold text-red-700 dark:text-red-300">{chefAgenceStats.chefsDeconnectes}</p>
                        </div>
                      </CardContent>
                    </Card>
                  </div>
                  
                  <div className="overflow-x-auto">
                    <Table>
                      <TableCaption className="text-xs md:text-sm">État des connexions des chefs d'agence.</TableCaption>
                      <TableHeader>
                        <TableRow>
                          <TableHead className="text-xs md:text-sm">Chef d'Agence</TableHead>
                          <TableHead className="text-xs md:text-sm">Agence</TableHead>
                          <TableHead className="text-center text-xs md:text-sm">État</TableHead>
                          <TableHead className="text-center text-xs md:text-sm">Dernière Connexion</TableHead>
                          <TableHead className="text-center text-xs md:text-sm">Dernière Déconnexion</TableHead>
                          <TableHead className="text-center text-xs md:text-sm">Durée Session</TableHead>
                          <TableHead className="text-center text-xs md:text-sm">Temps Connecté / Attendu</TableHead>
                          <TableHead className="text-center text-xs md:text-sm">Taux de Conformité (%)</TableHead>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {chefAgenceStatsData.map((chef, index) => (
                          <motion.tr 
                            key={chef.id}
                            variants={itemVariants}
                            initial="hidden"
                            animate="visible"
                            transition={{ delay: index * 0.05 }}
                            className="hover:bg-muted/50 dark:hover:bg-muted/20 text-xs md:text-sm"
                          >
                            <TableCell className="font-medium">{chef.nom}</TableCell>
                            <TableCell>{chef.agence}</TableCell>
                            <TableCell className="text-center">
                              {chef.estConnecte ? (
                                <div className="flex items-center justify-center">
                                  <CheckCircle2 className="h-5 w-5 text-green-500 mr-1" />
                                  <span className="text-green-500 font-medium">Connecté</span>
                                </div>
                              ) : (
                                <div className="flex items-center justify-center">
                                  <XCircle className="h-5 w-5 text-red-500 mr-1" />
                                  <span className="text-red-500">Déconnecté</span>
                                </div>
                              )}
                            </TableCell>
                            <TableCell className="text-center">{chef.derniereConnexion}</TableCell>
                            <TableCell className="text-center">{chef.derniereDeconnexion}</TableCell>
                            <TableCell className="text-center">{chef.derniereDuree}</TableCell>
                            <TableCell className="text-center">{chef.tempsTotalConnexion} / {chef.tempsAttendus}</TableCell>
                            <TableCell className="text-center">
                              <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2 md:h-2.5 relative">
                                <div 
                                  className={`h-2 md:h-2.5 rounded-full ${chef.tauxConformite < 50 ? 'bg-red-500' : chef.tauxConformite < 80 ? 'bg-yellow-500' : 'bg-green-500'}`} 
                                  style={{ width: `${chef.tauxConformite.toFixed(2)}%` }}
                                ></div>
                              </div>
                              {chef.tauxConformite.toFixed(2)}%
                            </TableCell>
                          </motion.tr>
                        ))}
                      </TableBody>
                    </Table>
                  </div>
                </>
              ) : (
                <div className="text-center py-10 text-muted-foreground">
                  <UserCog className="mx-auto h-10 w-10 md:h-12 md:w-12 mb-3 md:mb-4" />
                  <p className="text-base md:text-lg">Aucune donnée statistique des chefs d'agence à afficher.</p>
                  <p className="text-xs md:text-sm">Vérifiez vos filtres ou assurez-vous que des données de connexion existent.</p>
                </div>
              )}
            </>
          )}
        </CardContent>
      </Card>
    </motion.div>
  );
};

export default StatistiquesPage;
