
import { useToast } from '@/components/ui/use-toast';
import { parseISO } from 'date-fns';

const convertToCSV = (data) => {
  if (!data || data.length === 0) return '';
  const headers = Object.keys(data[0]).filter(h => h !== 'mdpPrepose');
  const csvRows = [
    headers.join(','),
    ...data.map(row =>
      headers.map(fieldName =>
        JSON.stringify(row[fieldName] === undefined || row[fieldName] === null ? '' : row[fieldName])
      ).join(',')
    )
  ];
  return csvRows.join('\r\n');
};

export const useGuichetieresActions = (saveData, setIsDialogOpen, setCurrentGuichetiere, resetForm) => {
  const { toast } = useToast();

  const handleFormSubmit = (formData, isEditing, currentGuichetiereData, currentGuichetieresList) => {
    if (!formData.matricule || !formData.nom || !formData.prenom || !formData.agenceAssigne || !formData.codePrepose || !formData.mdpPrepose) {
      toast({ title: 'Erreur', description: 'Veuillez remplir tous les champs obligatoires.', variant: 'destructive' });
      return;
    }

    if ((formData.disponibilite === 'Absent' || formData.disponibilite === 'Suspendu') && (!formData.dateDebutIndisponibilite || !formData.dateFinIndisponibilite)) {
      toast({ title: 'Erreur', description: 'Veuillez spécifier les dates de début et de fin pour l\'indisponibilité.', variant: 'destructive' });
      return;
    }
    
    if (formData.dateDebutIndisponibilite && formData.dateFinIndisponibilite) {
        try {
            if (parseISO(formData.dateDebutIndisponibilite) > parseISO(formData.dateFinIndisponibilite)) {
                toast({ title: 'Erreur de dates', description: 'La date de début d\'indisponibilité ne peut pas être après la date de fin.', variant: 'destructive'});
                return;
            }
        } catch (e) {
            toast({ title: 'Erreur de dates', description: 'Format de date invalide pour l\'indisponibilité.', variant: 'destructive'});
            return;
        }
    }


    let updatedGuichetieres;
    if (isEditing && currentGuichetiereData) {
      updatedGuichetieres = currentGuichetieresList.map(g => g.id === currentGuichetiereData.id ? { ...currentGuichetiereData, ...formData } : g);
      toast({ title: 'Succès', description: 'Guichetière modifiée avec succès.', className: "bg-green-500 text-white" });
    } else {
      const newGuichetiere = { id: Date.now().toString(), ...formData };
      updatedGuichetieres = [...currentGuichetieresList, newGuichetiere];
      toast({ title: 'Succès', description: 'Guichetière ajoutée avec succès.', className: "bg-green-500 text-white" });
    }
    saveData(updatedGuichetieres);
    setIsDialogOpen(false);
    if (setCurrentGuichetiere) setCurrentGuichetiere(null);
    if (resetForm) resetForm();
  };

  const handleDelete = (id, currentGuichetieresList) => {
    const updatedGuichetieres = currentGuichetieresList.filter(g => g.id !== id);
    saveData(updatedGuichetieres);
    toast({ title: 'Succès', description: 'Guichetière supprimée.', className: "bg-red-500 text-white" });
  };

  const handleExport = (guichetieresToExport) => {
    const csvData = convertToCSV(guichetieresToExport.map(({ mdpPrepose, ...rest }) => rest));
    if (!csvData) {
      toast({ title: "Rien à exporter", description: "Aucune donnée de guichetière à exporter.", variant: "destructive" });
      return;
    }
    const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", "pmu_guichetieres.csv");
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    toast({ title: "Exportation CSV réussie", description: "Les données des guichetières ont été exportées.", className: "bg-green-500 text-white" });
  };

  const handleImport = (event, currentGuichetieresList) => {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const text = e.target.result;
          const rows = text.split(/\r\n|\n/);
          if (rows.length < 2) throw new Error("Fichier CSV vide ou en-têtes manquants.");

          const headers = rows[0].split(',').map(h => h.replace(/"/g, '').trim());
          const requiredHeaders = ["matricule", "nom", "prenom", "codePrepose", "agenceAssigne"];
          const missingHeaders = requiredHeaders.filter(rh => !headers.includes(rh));
          if (missingHeaders.length > 0) {
            throw new Error(`En-têtes manquants: ${missingHeaders.join(', ')}.`);
          }

          const importedData = rows.slice(1).filter(row => row.trim() !== '').map(row => {
            const values = row.split(',').map(v => v.replace(/"/g, '').trim());
            let obj = {};
            headers.forEach((header, index) => {
              obj[header] = values[index];
            });
            obj.id = obj.id || Date.now().toString() + Math.random().toString(36).substr(2, 9);
            obj.mdpPrepose = obj.mdpPrepose || 'DefaultPass123';
            obj.disponibilite = obj.disponibilite || 'Disponible';
            return obj;
          });
          
          const mergedData = [...currentGuichetieresList];
          importedData.forEach(importedGuichetiere => {
              const existingIndex = mergedData.findIndex(g => g.matricule === importedGuichetiere.matricule);
              if (existingIndex !== -1) {
                  mergedData[existingIndex] = { ...mergedData[existingIndex], ...importedGuichetiere };
              } else {
                  mergedData.push(importedGuichetiere);
              }
          });

          saveData(mergedData);
          toast({ title: "Importation CSV réussie", description: `${importedData.length} guichetières importées/mises à jour.`, className: "bg-green-500 text-white" });
        } catch (error) {
          toast({ title: "Erreur d'importation CSV", description: `Impossible de lire le fichier: ${error.message}`, variant: "destructive", duration: 7000 });
        }
      };
      reader.readAsText(file);
    }
    if (event.target) event.target.value = null;
  };

  return { handleFormSubmit, handleDelete, handleExport, handleImport };
};
