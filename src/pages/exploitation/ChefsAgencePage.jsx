import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Dialog } from '@/components/ui/dialog';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { useToast } from '@/components/ui/use-toast';
import { motion } from 'framer-motion';
import { UserPlus, Search, Upload, Download, KeyRound } from 'lucide-react';
import ChefAgenceForm from '@/pages/exploitation/chefs_agence/ChefAgenceForm';
import ChefAgenceTable from '@/pages/exploitation/chefs_agence/ChefAgenceTable';
import { supabase } from '@/lib/supabaseClient';
import { Label } from '@/components/ui/label';

const ChefsAgencePage = () => {
  const [chefsAgence, setChefsAgence] = useState([]);
  const [agences, setAgences] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [currentChef, setCurrentChef] = useState(null);
  const [searchTerm, setSearchTerm] = useState('');
  const { toast } = useToast();
  const [isLoading, setIsLoading] = useState(false);

  const loadData = useCallback(async () => {
    setIsLoading(true);
    const { data: chefsData, error: chefsError } = await supabase.from('chefs_agence').select('*').order('nom', { ascending: true });
    if (chefsError) {
      toast({ title: "Erreur de chargement des chefs", description: chefsError.message, variant: "destructive" });
    } else {
      setChefsAgence(chefsData);
    }

    const { data: agencesData, error: agencesError } = await supabase.from('agences').select('id, nom, codePDV').order('nom', { ascending: true });
    if (agencesError) {
      toast({ title: "Erreur de chargement des agences", description: agencesError.message, variant: "destructive" });
    } else {
      setAgences(agencesData);
    }
    setIsLoading(false);
  }, [toast]);

  useEffect(() => {
    loadData();
  }, [loadData]);

  const resetCurrentChefAndForm = useCallback(() => {
    setCurrentChef(null);
  }, []);

  const handleFormSubmit = useCallback(async (formDataFromForm, isEditing) => {
    if (!formDataFromForm.matricule || !formDataFromForm.nom || !formDataFromForm.prenom || !formDataFromForm.agenceEnCharge || !formDataFromForm.mdp) {
      toast({ title: "Erreur de validation", description: "Veuillez remplir tous les champs obligatoires (Matricule, Mot de passe, Nom, Prénom, Agence).", variant: "destructive" });
      return;
    }
    
    setIsLoading(true);
    const dataToSave = { ...formDataFromForm };
    delete dataToSave.id; 
    delete dataToSave.photoFile;
    
    // Gérer l'upload de photo si nécessaire
    let photoUrl = dataToSave.photo_url;
    if (formDataFromForm.photoFile) {
      const file = formDataFromForm.photoFile;
      const fileName = `photos_chefs_agence/${formDataFromForm.matricule}_${Date.now()}.${file.name.split('.').pop()}`;
      
      const { data, error: uploadError } = await supabase.storage
        .from('pmu-mali-storage')
        .upload(fileName, file, {
          cacheControl: '3600',
          upsert: true,
        });
        
      if (uploadError) {
        toast({ title: "Erreur d'upload photo", description: uploadError.message, variant: "destructive" });
        setIsLoading(false);
        return;
      }
      
      const { data: publicUrlData } = supabase.storage.from('pmu-mali-storage').getPublicUrl(data.path);
      photoUrl = publicUrlData.publicUrl;
    } else if (dataToSave.photo_url && dataToSave.photo_url.startsWith('data:image')) {
      // Si c'est une data URL (capture de caméra) mais pas de fichier, convertir en Blob et uploader
      try {
        const res = await fetch(dataToSave.photo_url);
        const blob = await res.blob();
        const file = new File([blob], `capture_${formDataFromForm.matricule}.png`, { type: 'image/png' });
        
        const fileName = `photos_chefs_agence/${formDataFromForm.matricule}_${Date.now()}.png`;
        
        const { data, error: uploadError } = await supabase.storage
          .from('pmu-mali-storage')
          .upload(fileName, file, {
            cacheControl: '3600',
            upsert: true,
          });
          
        if (uploadError) {
          toast({ title: "Erreur d'upload photo", description: uploadError.message, variant: "destructive" });
          setIsLoading(false);
          return;
        }
        
        const { data: publicUrlData } = supabase.storage.from('pmu-mali-storage').getPublicUrl(data.path);
        photoUrl = publicUrlData.publicUrl;
      } catch (error) {
        toast({ title: "Erreur de traitement de l'image", description: error.message, variant: "destructive" });
        setIsLoading(false);
        return;
      }
    } else if (!dataToSave.photo_url && isEditing && currentChef && currentChef.photo_url) {
      // Si la photo a été supprimée et qu'il y en avait une avant, supprimer de Supabase Storage
      try {
        const filePath = new URL(currentChef.photo_url).pathname.split('/pmu-mali-storage/').pop();
        if (filePath) {
          await supabase.storage.from('pmu-mali-storage').remove([filePath]);
        }
      } catch (error) {
        console.error("Erreur lors de la suppression de l'ancienne photo:", error);
      }
      photoUrl = null;
    }
    
    // Mettre à jour l'URL de la photo
    dataToSave.photo_url = photoUrl;

    let error;
    if (isEditing && currentChef) {
      const { error: updateError } = await supabase.from('chefs_agence').update(dataToSave).eq('id', currentChef.id);
      error = updateError;
    } else {
      const { error: insertError } = await supabase.from('chefs_agence').insert(dataToSave);
      error = insertError;
    }

    if (error) {
      toast({ title: "Erreur d'enregistrement", description: error.message, variant: "destructive" });
    } else {
      toast({ title: "Succès", description: `Chef d'agence ${isEditing ? 'modifié' : 'ajouté'} avec succès.`, className: "bg-green-500 text-white" });
      setIsModalOpen(false);
      resetCurrentChefAndForm();
      loadData();
    }
    setIsLoading(false);
  }, [toast, currentChef, loadData, resetCurrentChefAndForm]);

  const handleAdd = useCallback(() => {
    resetCurrentChefAndForm();
    setIsModalOpen(true);
  }, [resetCurrentChefAndForm]);

  const handleEdit = useCallback((chef) => {
    setCurrentChef(chef);
    setIsModalOpen(true);
  }, []);

  const handleDelete = useCallback(async (id) => {
    setIsLoading(true);
    
    // Récupérer les infos du chef d'agence à supprimer
    const chefToDelete = chefsAgence.find(chef => chef.id === id);
    
    // Supprimer la photo si elle existe
    if (chefToDelete && chefToDelete.photo_url) {
      try {
        const filePath = new URL(chefToDelete.photo_url).pathname.split('/pmu-mali-storage/').pop();
        if (filePath) {
          await supabase.storage.from('pmu-mali-storage').remove([filePath]);
        }
      } catch (error) {
        console.error("Erreur lors de la suppression de la photo:", error);
      }
    }
    
    const { error } = await supabase.from('chefs_agence').delete().eq('id', id);
    if (error) {
      toast({ title: "Erreur de suppression", description: error.message, variant: "destructive" });
    } else {
      toast({ title: "Succès", description: "Chef d'agence supprimé avec succès.", className: "bg-red-500 text-white" });
      loadData();
    }
    setIsLoading(false);
  }, [loadData, toast, chefsAgence]);

  const filteredChefs = useMemo(() => 
    chefsAgence.filter(chef => {
      const searchTermLower = searchTerm.toLowerCase();
      return (
        chef.matricule.toLowerCase().includes(searchTermLower) ||
        chef.nom.toLowerCase().includes(searchTermLower) ||
        chef.prenom.toLowerCase().includes(searchTermLower) ||
        (chef.agenceEnCharge && chef.agenceEnCharge.toLowerCase().includes(searchTermLower)) ||
        (chef.codePDV && chef.codePDV.toLowerCase().includes(searchTermLower))
      );
    }), [chefsAgence, searchTerm]);

  const convertToCSV = (data) => {
    if (!data || data.length === 0) return '';
    const headers = ['matricule', 'nom', 'prenom', 'agenceEnCharge', 'codePDV', 'mdp'].join(',');
    const rows = data.map(row => 
      [row.matricule, row.nom, row.prenom, row.agenceEnCharge || '', row.codePDV || '', row.mdp].map(value => `"${String(value).replace(/"/g, '""')}"`).join(',')
    );
    return `${headers}\n${rows.join('\n')}`;
  };

  const handleExport = () => {
    const csvData = convertToCSV(chefsAgence);
    if (!csvData) {
        toast({ title: "Exportation échouée", description: "Aucune donnée à exporter.", variant: "destructive" });
        return;
    }
    const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', 'pmu_chefs_agence.csv');
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    toast({ title: "Exportation réussie", description: "Les données des chefs d'agence ont été exportées au format CSV.", className: "bg-green-500 text-white" });
  };

  const handleImport = async (event) => {
    const file = event.target.files[0];
    if (file) {
      setIsLoading(true);
      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const text = e.target.result;
          const rows = text.split('\n').filter(row => row.trim() !== '');
          if (rows.length < 2) throw new Error("Fichier CSV vide ou en-têtes manquants.");
          
          const headers = rows[0].trim().split(',').map(h => h.replace(/^"|"$/g, '').trim());
          const requiredHeaders = ['matricule', 'nom', 'prenom', 'mdp', 'agenceEnCharge'];
          
          if (!requiredHeaders.every(rh => headers.includes(rh))) {
             throw new Error(`En-têtes manquants. Requis: ${requiredHeaders.join(', ')}. Présents: ${headers.join(', ')}`);
          }

          const dataToUpsert = rows.slice(1).map(rowStr => {
            const values = rowStr.split(',').map(v => v.replace(/^"|"$/g, '').replace(/""/g, '"').trim());
            let obj = {};
            headers.forEach((header, index) => {
              obj[header] = values[index];
            });
            const agenceTrouvee = agences.find(a => a.nom === obj.agenceEnCharge);
            return {
              matricule: obj.matricule,
              nom: obj.nom,
              prenom: obj.prenom,
              mdp: obj.mdp,
              agenceEnCharge: obj.agenceEnCharge || null,
              codePDV: agenceTrouvee ? agenceTrouvee.codePDV : null,
            };
          }).filter(item => item.matricule && item.nom && item.prenom && item.mdp);

          if (dataToUpsert.length > 0) {
            const { error } = await supabase.from('chefs_agence').upsert(dataToUpsert, { onConflict: 'matricule' });
            if (error) throw error;
            toast({ title: "Importation réussie", description: `${dataToUpsert.length} chefs d'agence importés/mis à jour.`, className: "bg-green-500 text-white" });
            loadData();
          } else {
            toast({ title: "Erreur d'importation", description: "Aucune donnée valide trouvée dans le fichier CSV ou format incorrect.", variant: "destructive" });
          }
        } catch (error) {
          toast({ title: "Erreur d'importation", description: `Impossible de lire le fichier CSV: ${error.message}`, variant: "destructive" });
        } finally {
          setIsLoading(false);
        }
      };
      reader.readAsText(file, 'UTF-8');
    }
    if (event.target) event.target.value = null;
  };

  return (
    <motion.div 
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
      className="space-y-6"
    >
      <Card className="shadow-xl glassmorphism">
        <CardHeader>
          <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
            <div>
              <CardTitle className="text-3xl font-bold text-primary flex items-center">
                <KeyRound className="mr-3 h-8 w-8" /> Gestion des Chefs d'Agence
              </CardTitle>
              <CardDescription>Ajoutez, modifiez ou supprimez les informations des chefs d'agence.</CardDescription>
            </div>
            <Button onClick={handleAdd} className="bg-gradient-to-r from-primary to-green-600 hover:from-primary/90 hover:to-green-600/90 text-white" disabled={isLoading}>
              <UserPlus className="mr-2 h-4 w-4" /> Ajouter un Chef d'Agence
            </Button>
          </div>
          <div className="mt-6 flex flex-col md:flex-row gap-2">
            <div className="relative flex-grow">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-muted-foreground" />
              <Input 
                placeholder="Rechercher un chef d'agence..." 
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-10"
                disabled={isLoading}
              />
            </div>
            <Button variant="outline" asChild disabled={isLoading}>
                <Label htmlFor="import-chefs" className="cursor-pointer flex items-center">
                  <Upload className="mr-2 h-4 w-4" /> Importer (CSV)
                  <Input type="file" id="import-chefs" accept=".csv" onChange={handleImport} className="hidden" />
                </Label>
            </Button>
            <Button variant="outline" onClick={handleExport} disabled={isLoading || chefsAgence.length === 0}><Download className="mr-2 h-4 w-4" /> Exporter (CSV)</Button>
          </div>
        </CardHeader>
        <CardContent>
          {isLoading && chefsAgence.length === 0 ? (
             <p className="text-center text-muted-foreground py-8">Chargement des chefs d'agence...</p>
          ) : (
            <ChefAgenceTable chefs={filteredChefs} onEdit={handleEdit} onDelete={handleDelete} isLoading={isLoading} />
          )}
        </CardContent>
      </Card>

      <Dialog open={isModalOpen} onOpenChange={(isOpen) => { 
          setIsModalOpen(isOpen); 
          if (!isOpen) resetCurrentChefAndForm(); 
        }}>
        <ChefAgenceForm 
          isOpen={isModalOpen}
          onOpenChange={setIsModalOpen}
          onSubmit={handleFormSubmit}
          currentChef={currentChef}
          agences={agences}
          resetFormDataState={resetCurrentChefAndForm}
          isLoading={isLoading}
        />
      </Dialog>
    </motion.div>
  );
};

export default ChefsAgencePage;
