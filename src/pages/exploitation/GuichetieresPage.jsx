import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow, TableCaption } from '@/components/ui/table';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogTrigger, DialogClose } from '@/components/ui/dialog';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { PlusCircle, Edit, Trash2, Search, FileUp, FileDown, User, Phone, KeyRound, Briefcase, CircleDot, Eye, EyeOff, CalendarOff, Camera, UploadCloud } from 'lucide-react';
import { useToast } from '@/components/ui/use-toast';
import { motion } from 'framer-motion';
import { format, differenceInDays, parseISO, isValid as isValidDate } from 'date-fns';
import { fr } from 'date-fns/locale';
import { supabase } from '@/lib/supabaseClient';
import { Combobox } from '@/components/ui/Combobox';
import { Avatar, AvatarImage, AvatarFallback } from '@/components/ui/avatar';

const GuichetieresPage = () => {
  const { toast } = useToast();
  const [guichetieres, setGuichetieres] = useState([]);
  const [agences, setAgences] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [currentGuichetiere, setCurrentGuichetiere] = useState(null);
  const [formData, setFormData] = useState({
    matricule: '', codePrepose: '', mdpPrepose: '', nom: '', prenom: '', telephone: '', agenceAssigne: '', 
    disponibilite: 'Disponible', dateDebutIndisponibilite: null, dateFinIndisponibilite: null, photo_url: null
  });
  const [showMdpPrepose, setShowMdpPrepose] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [photoFile, setPhotoFile] = useState(null);
  const [isTakingPhoto, setIsTakingPhoto] = useState(false);
  const videoRef = useRef(null);
  const canvasRef = useRef(null);

  const agenceOptions = agences.map(agence => ({ value: agence.nom, label: agence.nom }));

  const loadData = useCallback(async () => {
    setIsLoading(true);
    const { data: guichetieresData, error: guichetieresError } = await supabase.from('guichetieres').select('*').order('nom', { ascending: true });
    if (guichetieresError) {
      toast({ title: 'Erreur chargement guichetières', description: guichetieresError.message, variant: 'destructive' });
    } else {
      setGuichetieres(guichetieresData);
    }

    const { data: agencesData, error: agencesError } = await supabase.from('agences').select('id, nom').order('nom', { ascending: true });
    if (agencesError) {
      toast({ title: 'Erreur chargement agences', description: agencesError.message, variant: 'destructive' });
    } else {
      setAgences(agencesData);
    }
    setIsLoading(false);
  }, [toast]);

  useEffect(() => {
    loadData();
  }, [loadData]);
  
  useEffect(() => {
    let stream;
    if (isTakingPhoto && videoRef.current) {
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(s => {
          stream = s;
          videoRef.current.srcObject = stream;
        })
        .catch(err => {
          console.error("Error accessing camera: ", err);
          toast({ title: "Erreur Caméra", description: "Impossible d'accéder à la caméra.", variant: "destructive" });
          setIsTakingPhoto(false);
        });
    }
    return () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
    };
  }, [isTakingPhoto, toast]);

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value === '' && (name === 'dateDebutIndisponibilite' || name === 'dateFinIndisponibilite') ? null : value }));
  };
  
  const handleSelectChange = (name, value) => {
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleAgenceSelect = (value) => {
    const selectedAgenceNom = agenceOptions.find(opt => opt.value.toLowerCase() === value.toLowerCase())?.value;
    setFormData(prev => ({
        ...prev,
        agenceAssigne: selectedAgenceNom || '',
    }));
  };

  const resetFormData = useCallback(() => {
    setFormData({
      matricule: '', codePrepose: '', mdpPrepose: '', nom: '', prenom: '', telephone: '', agenceAssigne: '', 
      disponibilite: 'Disponible', dateDebutIndisponibilite: null, dateFinIndisponibilite: null, photo_url: null
    });
    setShowMdpPrepose(false);
    setPhotoFile(null);
    setIsTakingPhoto(false);
  }, []);

  const handlePhotoUpload = (event) => {
    const file = event.target.files[0];
    if (file) {
      setPhotoFile(file);
      const reader = new FileReader();
      reader.onloadend = () => {
        setFormData(prev => ({ ...prev, photo_url: reader.result })); 
      };
      reader.readAsDataURL(file);
    }
  };

  const capturePhoto = () => {
    if (videoRef.current && canvasRef.current) {
      const video = videoRef.current;
      const canvas = canvasRef.current;
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const context = canvas.getContext('2d');
      context.drawImage(video, 0, 0, canvas.width, canvas.height);
      const dataUrl = canvas.toDataURL('image/png');
      
      fetch(dataUrl)
        .then(res => res.blob())
        .then(blob => {
          const file = new File([blob], "capture.png", { type: "image/png" });
          setPhotoFile(file);
          setFormData(prev => ({ ...prev, photo_url: dataUrl }));
          setIsTakingPhoto(false); 
        });
    }
  };

  const uploadPhotoToSupabase = async (file, matricule) => {
    if (!file) return null;
    const fileName = `photos_guichetieres/${matricule}_${Date.now()}.${file.name.split('.').pop()}`;
    const { data, error } = await supabase.storage
      .from('pmu-mali-storage')
      .upload(fileName, file, {
        cacheControl: '3600',
        upsert: true, 
      });

    if (error) {
      toast({ title: "Erreur d'upload photo", description: error.message, variant: "destructive" });
      return null;
    }
    
    const { data: publicUrlData } = supabase.storage.from('pmu-mali-storage').getPublicUrl(data.path);
    return publicUrlData.publicUrl;
  };

  const handleSubmit = async () => {
    if (!formData.matricule || !formData.nom || !formData.prenom || !formData.agenceAssigne || !formData.codePrepose || !formData.mdpPrepose) {
      toast({ title: 'Erreur', description: 'Veuillez remplir tous les champs obligatoires (Matricule, Nom, Prénom, Agence, Code et MDP Préposé).', variant: 'destructive' });
      return;
    }

    if ((formData.disponibilite === 'Absent' || formData.disponibilite === 'Suspendu') && (!formData.dateDebutIndisponibilite || !formData.dateFinIndisponibilite)) {
      toast({ title: 'Erreur', description: 'Les dates de début et de fin d\'indisponibilité sont requises pour ce statut.', variant: 'destructive' });
      return;
    }
    if (formData.dateDebutIndisponibilite && formData.dateFinIndisponibilite && parseISO(formData.dateFinIndisponibilite) < parseISO(formData.dateDebutIndisponibilite)) {
      toast({ title: 'Erreur de dates', description: 'La date de fin d\'indisponibilité ne peut pas être antérieure à la date de début.', variant: 'destructive' });
      return;
    }

    setIsLoading(true);
    let uploadedPhotoUrl = currentGuichetiere?.photo_url || null;

    if (photoFile) {
        const newUrl = await uploadPhotoToSupabase(photoFile, formData.matricule);
        if (newUrl) {
            uploadedPhotoUrl = newUrl;
        } else {
            setIsLoading(false);
            return; 
        }
    } else if (formData.photo_url && formData.photo_url.startsWith('data:image')) {
      // Cas où une photo a été capturée mais pas encore uploadée si c'est un nouvel ajout.
      // Pour la modification, si photo_url est une data URL, c'est une nouvelle photo capturée.
      // Si `currentGuichetiere` existe et que `formData.photo_url` est la même que `currentGuichetiere.photo_url`,
      // alors ce n'est pas une nouvelle photo.
      // Ce cas est normalement géré par photoFile, mais double sécurité.
    } else if (!formData.photo_url && currentGuichetiere && currentGuichetiere.photo_url) {
      // Si photo_url a été effacé dans le formulaire mais existe dans currentGuichetiere, on la supprime.
      // (Optionnel : logique de suppression de l'ancien fichier dans Supabase Storage)
      uploadedPhotoUrl = null;
    }


    const dataToSave = { ...formData, photo_url: uploadedPhotoUrl };
    if (dataToSave.disponibilite === 'Disponible') {
        dataToSave.dateDebutIndisponibilite = null;
        dataToSave.dateFinIndisponibilite = null;
    }
    delete dataToSave.id; 

    let error;
    if (currentGuichetiere) {
      const { error: updateError } = await supabase.from('guichetieres').update(dataToSave).eq('id', currentGuichetiere.id);
      error = updateError;
    } else {
      const { error: insertError } = await supabase.from('guichetieres').insert(dataToSave);
      error = insertError;
    }

    if (error) {
      toast({ title: 'Erreur d\'enregistrement', description: error.message, variant: 'destructive' });
    } else {
      toast({ title: 'Succès', description: `Guichetière ${currentGuichetiere ? 'modifiée' : 'ajoutée'} avec succès.`, className: "bg-green-500 text-white" });
      setIsDialogOpen(false);
      setCurrentGuichetiere(null);
      resetFormData();
      loadData();
    }
    setIsLoading(false);
  };

  const openDialog = (guichetiere = null) => {
    setCurrentGuichetiere(guichetiere);
    if (guichetiere) {
      setFormData({ 
        ...guichetiere, 
        dateDebutIndisponibilite: guichetiere.dateDebutIndisponibilite ? format(parseISO(guichetiere.dateDebutIndisponibilite), 'yyyy-MM-dd') : null,
        dateFinIndisponibilite: guichetiere.dateFinIndisponibilite ? format(parseISO(guichetiere.dateFinIndisponibilite), 'yyyy-MM-dd') : null,
        photo_url: guichetiere.photo_url || null
      });
    } else {
      resetFormData();
    }
    setPhotoFile(null);
    setIsTakingPhoto(false);
    setIsDialogOpen(true);
  };

  const handleDelete = async (id) => {
    setIsLoading(true);
    const guichetiereToDelete = guichetieres.find(g => g.id === id);
    if (guichetiereToDelete && guichetiereToDelete.photo_url) {
        try {
            const filePath = new URL(guichetiereToDelete.photo_url).pathname.split('/pmu-mali-storage/').pop();
            if (filePath) {
                await supabase.storage.from('pmu-mali-storage').remove([filePath]);
            }
        } catch (e) {
            console.error("Error parsing or deleting photo from storage:", e);
        }
    }

    const { error } = await supabase.from('guichetieres').delete().eq('id', id);
    if (error) {
      toast({ title: 'Erreur de suppression', description: error.message, variant: 'destructive' });
    } else {
      toast({ title: 'Succès', description: 'Guichetière supprimée.', className: "bg-red-500 text-white" });
      loadData();
    }
    setIsLoading(false);
  };

  const filteredGuichetieres = guichetieres.filter(g => 
    Object.entries(g).some(([key, val]) => {
      if (key === 'codePrepose' || key === 'mdpPrepose' || key === 'photo_url') return false; 
      return String(val).toLowerCase().includes(searchTerm.toLowerCase());
    })
  );
  
  const disponibiliteOptions = ['Disponible', 'Absent', 'Suspendu'];

  const getDisponibiliteInfo = (g) => {
    if (g.disponibilite === 'Disponible') return <span className="text-green-500">Disponible</span>;
    
    let infoText = g.disponibilite === 'Absent' ? <span className="text-yellow-500">Absent(e)</span> : <span className="text-red-500">Suspendu(e)</span>;
    
    if (g.dateDebutIndisponibilite && g.dateFinIndisponibilite) {
      const debut = parseISO(g.dateDebutIndisponibilite);
      const fin = parseISO(g.dateFinIndisponibilite);
      if (isValidDate(debut) && isValidDate(fin)) {
        const jours = differenceInDays(fin, debut) + 1;
        const formattedDebut = format(debut, 'dd/MMM/yy', { locale: fr });
        const formattedFin = format(fin, 'dd/MMM/yy', { locale: fr });
        return (
          <div className="flex flex-col text-xs">
            {infoText}
            <span className="text-muted-foreground">Du {formattedDebut} au {formattedFin} ({jours} jour{jours > 1 ? 's' : ''})</span>
          </div>
        );
      }
    }
    return infoText;
  };
  
  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 },
  };

  const convertToCSV = (data) => {
    if (!data || data.length === 0) return '';
    const headers = ['matricule', 'nom', 'prenom', 'telephone', 'agenceAssigne', 'disponibilite', 'dateDebutIndisponibilite', 'dateFinIndisponibilite', 'codePrepose', 'photo_url'].join(',');
    const rows = data.map(row => 
      [row.matricule, row.nom, row.prenom, row.telephone || '', row.agenceAssigne || '', row.disponibilite, row.dateDebutIndisponibilite || '', row.dateFinIndisponibilite || '', row.codePrepose, row.photo_url || ''].map(value => `"${String(value).replace(/"/g, '""')}"`).join(',')
    );
    return `${headers}\n${rows.join('\n')}`;
  };

  const handleExport = () => {
    const csvData = convertToCSV(guichetieres);
    if (!csvData) {
        toast({ title: "Exportation échouée", description: "Aucune donnée à exporter.", variant: "destructive" });
        return;
    }
    const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', 'pmu_guichetieres.csv');
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    toast({ title: "Exportation réussie", description: "Les données des guichetières ont été exportées au format CSV.", className: "bg-green-500 text-white" });
  };

  const handleImport = async (event) => {
    const file = event.target.files[0];
    if (file) {
      setIsLoading(true);
      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const text = e.target.result;
          const rows = text.split('\n').filter(row => row.trim() !== '');
          if (rows.length < 2) throw new Error("Fichier CSV vide ou en-têtes manquants.");
          
          const headers = rows[0].trim().split(',').map(h => h.replace(/^"|"$/g, '').trim());
          const requiredHeaders = ['matricule', 'nom', 'prenom', 'codePrepose', 'mdpPrepose', 'agenceAssigne'];
          if (!requiredHeaders.every(rh => headers.includes(rh))) {
            throw new Error(`En-têtes manquants. Requis: ${requiredHeaders.join(', ')}. Présents: ${headers.join(', ')}`);
          }

          const dataToUpsert = rows.slice(1).map(rowStr => {
            const values = rowStr.split(',').map(v => v.replace(/^"|"$/g, '').replace(/""/g, '"').trim());
            let obj = {};
            headers.forEach((header, index) => {
              obj[header] = values[index];
            });
            return {
              matricule: obj.matricule,
              codePrepose: obj.codePrepose,
              mdpPrepose: obj.mdpPrepose,
              nom: obj.nom,
              prenom: obj.prenom,
              telephone: obj.telephone || null,
              agenceAssigne: obj.agenceAssigne || null,
              disponibilite: obj.disponibilite || 'Disponible',
              dateDebutIndisponibilite: obj.dateDebutIndisponibilite || null,
              dateFinIndisponibilite: obj.dateFinIndisponibilite || null,
              photo_url: obj.photo_url || null, 
            };
          }).filter(item => item.matricule && item.nom && item.prenom && item.codePrepose && item.mdpPrepose);

          if (dataToUpsert.length > 0) {
            const { error } = await supabase.from('guichetieres').upsert(dataToUpsert, { onConflict: 'matricule' });
            if (error) throw error;
            toast({ title: "Importation réussie", description: `${dataToUpsert.length} guichetières importées/mises à jour.`, className: "bg-green-500 text-white" });
            loadData();
          } else {
            toast({ title: "Erreur d'importation", description: "Aucune donnée valide trouvée dans le fichier CSV ou format incorrect.", variant: "destructive" });
          }
        } catch (error) {
          toast({ title: "Erreur d'importation", description: `Impossible de lire le fichier CSV: ${error.message}`, variant: "destructive" });
        } finally {
          setIsLoading(false);
        }
      };
      reader.readAsText(file, 'UTF-8');
    }
    if (event.target) event.target.value = null;
  };


  return (
    <motion.div 
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.5 }}
      className="space-y-6"
    >
      <Card className="shadow-xl glassmorphism">
        <CardHeader>
          <div className="flex flex-col md:flex-row justify-between items-center gap-4">
            <div>
              <CardTitle className="text-3xl font-bold text-primary">Gestion des Guichetières</CardTitle>
              <CardDescription>Gérez les informations et la disponibilité des guichetières.</CardDescription>
            </div>
            <Dialog open={isDialogOpen} onOpenChange={(isOpen) => { setIsDialogOpen(isOpen); if (!isOpen) resetFormData(); }}>
              <DialogTrigger asChild>
                <Button onClick={() => openDialog()} className="bg-gradient-to-r from-primary to-green-600 hover:from-primary/90 hover:to-green-600/90 text-white" disabled={isLoading}>
                  <PlusCircle className="mr-2 h-5 w-5" /> Ajouter une Guichetière
                </Button>
              </DialogTrigger>
              <DialogContent className="sm:max-w-lg glassmorphism">
                <DialogHeader>
                  <DialogTitle className="text-2xl text-primary">{currentGuichetiere ? 'Modifier' : 'Ajouter'} une Guichetière</DialogTitle>
                </DialogHeader>
                <div className="grid gap-4 py-4 max-h-[70vh] overflow-y-auto p-1">
                  {[
                    { id: 'matricule', label: 'Matricule', icon: <User className="h-4 w-4" /> },
                    { id: 'codePrepose', label: 'Code Préposé', icon: <KeyRound className="h-4 w-4" /> },
                    { id: 'mdpPrepose', label: 'MDP Préposé', type: showMdpPrepose ? 'text' : 'password', icon: <KeyRound className="h-4 w-4" />, isPassword: true },
                    { id: 'nom', label: 'Nom', icon: <User className="h-4 w-4" /> },
                    { id: 'prenom', label: 'Prénom', icon: <User className="h-4 w-4" /> },
                    { id: 'telephone', label: 'Numéro de Téléphone', type: 'tel', icon: <Phone className="h-4 w-4" /> }
                  ].map(field => (
                    <div className="grid grid-cols-4 items-center gap-4" key={field.id}>
                      <Label htmlFor={field.id} className="text-right flex items-center justify-end">
                        {field.icon && React.cloneElement(field.icon, { className: 'mr-1' })}
                        {field.label}
                      </Label>
                      <div className="col-span-3 relative">
                        <Input id={field.id} name={field.id} type={field.type || 'text'} value={formData[field.id] || ''} onChange={handleInputChange} className="pr-10" disabled={isLoading} />
                        {field.isPassword && (
                           <Button
                            type="button"
                            variant="ghost"
                            size="icon"
                            className="absolute right-1 top-1/2 -translate-y-1/2 h-7 w-7"
                            onClick={() => setShowMdpPrepose(prev => !prev)}
                            disabled={isLoading}
                          >
                            {showMdpPrepose ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                          </Button>
                        )}
                      </div>
                    </div>
                  ))}
                  <div className="grid grid-cols-4 items-center gap-4">
                    <Label htmlFor="agenceAssigne" className="text-right flex items-center justify-end"><Briefcase className="h-4 w-4 mr-1" />Agence Assignée</Label>
                     <div className="col-span-3">
                        <Combobox
                          options={agenceOptions}
                          value={formData.agenceAssigne}
                          onSelect={handleAgenceSelect}
                          placeholder="Sélectionner une agence"
                          searchPlaceholder="Rechercher une agence..."
                          emptyText="Aucune agence trouvée."
                          disabled={isLoading}
                        />
                      </div>
                  </div>
                  <div className="grid grid-cols-4 items-center gap-4">
                    <Label htmlFor="photo" className="text-right flex items-center justify-end"><Camera className="h-4 w-4 mr-1" />Photo</Label>
                    <div className="col-span-3 space-y-2">
                        {formData.photo_url && typeof formData.photo_url === 'string' && (
                            <div className="mt-2">
                                <img-replace src={formData.photo_url} alt="Aperçu photo" className="h-24 w-24 object-cover rounded border" />
                                <Button variant="link" size="sm" onClick={() => setFormData(prev => ({...prev, photo_url: null}))} disabled={isLoading}>Supprimer photo</Button>
                            </div>
                        )}
                         {isTakingPhoto && (
                            <div className="mt-2">
                                <video ref={videoRef} autoPlay className="w-full rounded border"></video>
                                <canvas ref={canvasRef} className="hidden"></canvas>
                                <div className="flex gap-2 mt-2">
                                    <Button onClick={capturePhoto} type="button" disabled={isLoading}>Prendre la photo</Button>
                                    <Button variant="outline" onClick={() => setIsTakingPhoto(false)} type="button" disabled={isLoading}>Annuler</Button>
                                </div>
                            </div>
                        )}
                        {!isTakingPhoto && (
                            <div className="flex gap-2">
                                <Button type="button" variant="outline" onClick={() => setIsTakingPhoto(true)} className="flex items-center" disabled={isLoading}>
                                    <Camera className="mr-2 h-4 w-4" /> Prendre Photo
                                </Button>
                                <Button asChild variant="outline" className="flex items-center" disabled={isLoading}>
                                    <Label htmlFor="photo-upload" className="cursor-pointer m-0 p-2 h-full">
                                        <UploadCloud className="mr-2 h-4 w-4" /> Uploader
                                    </Label>
                                </Button>
                                <Input id="photo-upload" type="file" accept="image/*" onChange={handlePhotoUpload} className="hidden" disabled={isLoading}/>
                            </div>
                        )}
                    </div>
                  </div>

                  <div className="grid grid-cols-4 items-center gap-4">
                    <Label htmlFor="disponibilite" className="text-right flex items-center justify-end"><CircleDot className="h-4 w-4 mr-1" />Disponibilité</Label>
                    <Select name="disponibilite" value={formData.disponibilite} onValueChange={(value) => handleSelectChange('disponibilite', value)} disabled={isLoading}>
                      <SelectTrigger className="col-span-3">
                        <SelectValue placeholder="Statut de disponibilité" />
                      </SelectTrigger>
                      <SelectContent>
                        {disponibiliteOptions.map(opt => (
                          <SelectItem key={opt} value={opt}>{opt}</SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  {(formData.disponibilite === 'Absent' || formData.disponibilite === 'Suspendu') && (
                    <>
                      <div className="grid grid-cols-4 items-center gap-4">
                        <Label htmlFor="dateDebutIndisponibilite" className="text-right flex items-center justify-end"><CalendarOff className="h-4 w-4 mr-1" />Début Indisponibilité</Label>
                        <Input id="dateDebutIndisponibilite" name="dateDebutIndisponibilite" type="date" value={formData.dateDebutIndisponibilite || ''} onChange={handleInputChange} className="col-span-3" disabled={isLoading} />
                      </div>
                      <div className="grid grid-cols-4 items-center gap-4">
                        <Label htmlFor="dateFinIndisponibilite" className="text-right flex items-center justify-end"><CalendarOff className="h-4 w-4 mr-1" />Fin Indisponibilité</Label>
                        <Input id="dateFinIndisponibilite" name="dateFinIndisponibilite" type="date" value={formData.dateFinIndisponibilite || ''} onChange={handleInputChange} className="col-span-3" disabled={isLoading} />
                      </div>
                    </>
                  )}
                </div>
                <DialogFooter>
                  <DialogClose asChild><Button variant="outline" type="button" onClick={resetFormData} disabled={isLoading}>Annuler</Button></DialogClose>
                  <Button onClick={handleSubmit} className="bg-primary hover:bg-primary/90" disabled={isLoading}>
                    {isLoading ? 'Enregistrement...' : (currentGuichetiere ? 'Sauvegarder' : 'Ajouter')}
                  </Button>
                </DialogFooter>
              </DialogContent>
            </Dialog>
          </div>
          <div className="mt-6 flex flex-col md:flex-row gap-4">
            <div className="relative flex-grow">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-muted-foreground" />
              <Input 
                type="text" 
                placeholder="Rechercher (Nom, Prénom, Matricule...)" 
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-10 w-full"
                disabled={isLoading}
              />
            </div>
             <div className="flex gap-2">
              <Button variant="outline" asChild disabled={isLoading}>
                <Label htmlFor="import-guichetieres" className="cursor-pointer flex items-center">
                  <FileUp className="mr-2 h-4 w-4" /> Importer (CSV)
                  <Input type="file" id="import-guichetieres" accept=".csv" onChange={handleImport} className="hidden" />
                </Label>
              </Button>
              <Button variant="outline" onClick={handleExport} disabled={isLoading || guichetieres.length === 0}><FileDown className="mr-2 h-4 w-4" /> Exporter (CSV)</Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {isLoading && guichetieres.length === 0 ? (
            <p className="text-center text-muted-foreground py-8">Chargement des guichetières...</p>
          ) : (
            <Table>
              <TableCaption>{filteredGuichetieres.length === 0 ? "Aucune guichetière trouvée." : `Liste de ${filteredGuichetieres.length} guichetière(s).`}</TableCaption>
              <TableHeader>
                <TableRow>
                  <TableHead>Photo</TableHead>
                  <TableHead>Matricule</TableHead>
                  <TableHead>Code Préposé</TableHead>
                  <TableHead>Nom</TableHead>
                  <TableHead>Prénom</TableHead>
                  <TableHead>Téléphone</TableHead>
                  <TableHead>Agence Assignée</TableHead>
                  <TableHead>Disponibilité</TableHead>
                  <TableHead>Début Indisponibilité</TableHead>
                  <TableHead>Fin Indisponibilité</TableHead>
                  <TableHead className="text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredGuichetieres.map((guichetiere, index) => (
                  <motion.tr 
                    key={guichetiere.id}
                    variants={itemVariants}
                    initial="hidden"
                    animate="visible"
                    transition={{ delay: index * 0.05 }}
                  >
                    <TableCell>
                      {guichetiere.photo_url ? (
                        <img src={guichetiere.photo_url} alt={`${guichetiere.prenom} ${guichetiere.nom}`} className="w-10 h-10 rounded-full object-cover" />
                      ) : (
                        <div className="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center">
                          <User className="h-6 w-6 text-gray-400" />
                        </div>
                      )}
                    </TableCell>
                    <TableCell>{guichetiere.matricule}</TableCell>
                    <TableCell>{guichetiere.codePrepose}</TableCell>
                    <TableCell>{guichetiere.nom}</TableCell>
                    <TableCell>{guichetiere.prenom}</TableCell>
                    <TableCell>{guichetiere.telephone}</TableCell>
                    <TableCell>{guichetiere.agenceAssigne}</TableCell>
                    <TableCell>
                      <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                        guichetiere.disponibilite === 'Disponible' ? 'bg-green-100 text-green-800' :
                        guichetiere.disponibilite === 'Absent' ? 'bg-yellow-100 text-yellow-800' :
                        'bg-red-100 text-red-800'
                      }`}>
                        {guichetiere.disponibilite}
                      </span>
                    </TableCell>
                    <TableCell>{guichetiere.dateDebutIndisponibilite || 'N/A'}</TableCell>
                    <TableCell>{guichetiere.dateFinIndisponibilite || 'N/A'}</TableCell>
                    <TableCell className="text-right space-x-1">
                      <Button variant="ghost" size="icon" onClick={() => openDialog(guichetiere)} className="text-blue-500 hover:text-blue-700" disabled={isLoading}>
                        <Edit className="h-4 w-4" />
                      </Button>
                      <Dialog>
                          <DialogTrigger asChild>
                            <Button variant="ghost" size="icon" className="text-red-500 hover:text-red-700" disabled={isLoading}>
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </DialogTrigger>
                          <DialogContent className="sm:max-w-md">
                              <DialogHeader>
                                  <DialogTitle>Confirmer la suppression</DialogTitle>
                                  <DialogDescription>
                                      Êtes-vous sûr de vouloir supprimer la guichetière {guichetiere.prenom} {guichetiere.nom} ? Cette action est irréversible et supprimera les plannings et pointages associés.
                                  </DialogDescription>
                              </DialogHeader>
                              <DialogFooter>
                                  <DialogClose asChild><Button variant="outline" disabled={isLoading}>Annuler</Button></DialogClose>
                                  <Button variant="destructive" onClick={() => handleDelete(guichetiere.id)} disabled={isLoading}>
                                    {isLoading ? 'Suppression...' : 'Supprimer'}
                                  </Button>
                              </DialogFooter>
                          </DialogContent>
                      </Dialog>
                    </TableCell>
                  </motion.tr>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </motion.div>
  );
};

export default GuichetieresPage;
