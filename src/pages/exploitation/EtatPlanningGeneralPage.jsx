import React, { useState, useEffect, useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '../../components/ui/card';
import { Loader2 } from 'lucide-react';
import { motion } from 'framer-motion';
import {
  format,
  startOfMonth,
  endOfMonth,
  eachDayOfInterval,
  isValid,
  subDays,
  startOfWeek,
  endOfWeek,
  subWeeks,
  subMonths,
  startOfYear,
  endOfYear,
  getDay,
  isSameDay,
  isWithinInterval
} from 'date-fns';
import { fr } from 'date-fns/locale';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
  TableCaption
} from '../../components/ui/table';
import { Button } from '../../components/ui/button';
import { Input } from '../../components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from '../../components/ui/select';
import { Label } from '../../components/ui/label';
import { CalendarIcon, FileDown } from 'lucide-react';
import { Popover, PopoverContent, PopoverTrigger } from '../../components/ui/popover';
import { Calendar } from '../../components/ui/calendar';
import { useToast } from '../../components/ui/use-toast';
import { supabase } from '../../lib/supabaseClient';
import { cn } from '../../lib/utils';

const PERIOD_OPTIONS = [
  { value: 'today',      label: "Aujourd'hui" },
  { value: 'yesterday',  label: 'Hier' },
  { value: 'this_week',  label: 'Cette semaine' },
  { value: 'last_week',  label: 'Semaine dernière' },
  { value: 'this_month', label: 'Ce mois-ci' },
  { value: 'last_month', label: 'Mois dernier' },
  { value: 'this_year',  label: 'Cette année' },
  { value: 'custom',     label: 'Plage personnalisée' }
];

const EtatPlanningGeneralPage = () => {
  const { toast } = useToast();
  const [isLoading, setIsLoading] = useState(false);

  // Données brutes
  const [agences, setAgences] = useState([]);
  const [chefsAgence, setChefsAgence] = useState([]);
  const [planningData, setPlanningData] = useState([]);
  const [guichetieres, setGuichetieres] = useState([]);
  const [selectedModalData, setSelectedModalData] = useState(null);

  // Filtres textuels
  const [filterAgence, setFilterAgence] = useState('');
  const [filterChef,    setFilterChef]    = useState('');

  // Sélecteur de période
  const [dateFilterOption, setDateFilterOption] = useState('this_month');
  const [dateRange, setDateRange] = useState({
    start: startOfMonth(new Date()),
    end:   endOfMonth(new Date())
  });
  const showCalendar = dateFilterOption === 'custom';

  // Recalcul automatique de dateRange
  useEffect(() => {
    const today = new Date();
    let start, end;

    switch (dateFilterOption) {
      case 'today':
        start = end = today; break;
      case 'yesterday':
        start = end = subDays(today, 1); break;
      case 'this_week':
        start = startOfWeek(today, { weekStartsOn: 1 });
        end   = endOfWeek(today,   { weekStartsOn: 1 });
        break;
      case 'last_week': {
        const lw = subWeeks(today, 1);
        start = startOfWeek(lw, { weekStartsOn: 1 });
        end   = endOfWeek(lw,   { weekStartsOn: 1 });
        break;
      }
      case 'this_month':
        start = startOfMonth(today);
        end   = endOfMonth(today);
        break;
      case 'last_month': {
        const lm = subMonths(today, 1);
        start = startOfMonth(lm);
        end   = endOfMonth(lm);
        break;
      }
      case 'this_year':
        start = startOfYear(today);
        end   = endOfYear(today);
        break;
      case 'custom':
        return; // on conserve l'ancien dateRange
      default:
        return;
    }

    setDateRange({ start, end });
  }, [dateFilterOption]);

  // Chargement des données Supabase
  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      try {
        // Agences
        const { data: agencesData, error: agencesError } = await supabase
          .from('agences').select('*').order('nom', { ascending: true });
        if (agencesError) throw agencesError;
        setAgences(agencesData || []);

        // Chefs d'agence
        const { data: chefsData, error: chefsError } = await supabase
          .from('chefs_agence').select('*').order('nom', { ascending: true });
        if (chefsError) throw chefsError;
        setChefsAgence(chefsData || []);

        // Guichetières
        const { data: guichetieresData, error: guichetieresError } = await supabase
          .from('guichetieres').select('id, matricule, nom, prenom, photo_url');
        if (guichetieresError) throw guichetieresError;
        setGuichetieres(guichetieresData || []);

        // Planning
        if (isValid(dateRange.start) && isValid(dateRange.end)) {
          const { data: planningRecords, error: planningError } = await supabase
            .from('planning')
            .select('date, agenceNom, guichetiereId')
            .gte('date', format(dateRange.start, 'yyyy-MM-dd'))
            .lte('date', format(dateRange.end,   'yyyy-MM-dd'));
          if (planningError) throw planningError;
          setPlanningData(planningRecords || []);
        }
      } catch (error) {
        toast({ title: "Erreur de chargement", description: error.message, variant: "destructive" });
      } finally {
        setIsLoading(false);
      }
    };
    fetchData();
  }, [dateRange, toast]);

  // Stats par agence
  const planningStats = useMemo(() => {
    if (!agences.length || !isValid(dateRange.start) || !isValid(dateRange.end)) return [];

    const days = eachDayOfInterval({ start: dateRange.start, end: dateRange.end });
    const totalDays = days.length;

    return agences.map(agence => {
      const chef = chefsAgence.find(c => c.agenceEnCharge === agence.nom);
      let totalPlanned = 0;

      days.forEach(day => {
        const dayStr = format(day, 'yyyy-MM-dd');
        const entries = planningData.filter(p => p.date === dayStr && p.agenceNom === agence.nom);
        totalPlanned += new Set(entries.map(e => e.guichetiereId)).size;
      });

      const nTer = parseInt(agence.nbreTerminaux) || 0;
      const toPlan = nTer * totalDays;
      const rate   = toPlan > 0 ? Math.round((totalPlanned / toPlan) * 100) : 0;

      return {
        id:           agence.id,
        agenceNom:    agence.nom,
        codePDV:      agence.codePDV,
        chefNom:      chef ? `${chef.prenom} ${chef.nom}` : 'N/A',
        nTer,
        nJours:       totalDays,
        toPlan,
        planned:      totalPlanned,
        rate
      };
    });
  }, [agences, chefsAgence, planningData, dateRange]);

  // Application des filtres textuels
  const filteredStats = useMemo(() =>
    planningStats.filter(stat =>
      (!filterAgence || stat.agenceNom.toLowerCase().includes(filterAgence.toLowerCase())) &&
      (!filterChef   || stat.chefNom.toLowerCase().includes(filterChef.toLowerCase()))
    )
  , [planningStats, filterAgence, filterChef]);

  // Export CSV (inchangé)
  const handleExport = () => {
    if (!filteredStats.length) {
      toast({ title: "Export impossible", description: "Aucune donnée à exporter.", variant: "destructive" });
      return;
    }
    // … code d’export …
  };

  // Texte de la période
  const displayDateRange = useMemo(() => {
    if (!isValid(dateRange.start) || !isValid(dateRange.end)) return '';
    const s = format(dateRange.start, 'dd MMM yyyy', { locale: fr });
    const e = format(dateRange.end,   'dd MMM yyyy', { locale: fr });
    return s === e ? `le ${s}` : `du ${s} au ${e}`;
  }, [dateRange]);

  // Pour la vue calendrier
  const calendarMonth = useMemo(() => {
    // Pour toujours afficher le mois complet qui contient la plage de dates sélectionnée
    if (!isValid(dateRange.start)) return new Date();
    return dateRange.start;
  }, [dateRange]);

  const daysToDisplay = useMemo(() =>
    isValid(calendarMonth)
      ? eachDayOfInterval({ start: startOfMonth(calendarMonth), end: endOfMonth(calendarMonth) })
      : []
  , [calendarMonth]);

  const firstDayOffset = useMemo(() => {
    if (!isValid(calendarMonth)) return 0;
    const d = getDay(startOfMonth(calendarMonth));
    return d === 0 ? 6 : d - 1;
  }, [calendarMonth]);
  
  const emptyStartCells = useMemo(() => Array(firstDayOffset).fill(null), [firstDayOffset]);

  const getPlanningForDayAndAgence = (date, agenceNom) => {
    const ds = format(date, 'yyyy-MM-dd');
    return planningData.filter(p => p.date === ds && p.agenceNom === agenceNom);
  };

  const handleDayClick = (date, agence) => {
    if (isWithinInterval(date, { start: dateRange.start, end: dateRange.end })) {
      setSelectedModalData({ date, agence });
    }
  };
  const closeModal = () => setSelectedModalData(null);

  const getGuichetieresForDayAndAgence = (date, agenceNom) => {
    const entries = getPlanningForDayAndAgence(date, agenceNom);
    const ids = Array.from(new Set(entries.map(p => p.guichetiereId)));
    return ids.map(id => guichetieres.find(g => g.id === id)).filter(Boolean);
  };

  return (
    <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.5 }} className="space-y-6">
      {/* --- Première carte : tableau --- */}
      <Card className="shadow-xl glassmorphism">
        <CardHeader>
          <div className="flex flex-col md:flex-row justify-between items-center gap-4">
            <div>
              <CardTitle className="text-3xl font-bold text-primary">État du Planning Général</CardTitle>
              <CardDescription>Visualisez l'état de planification par agence.</CardDescription>
            </div>
            <Button onClick={handleExport} variant="outline" disabled={!filteredStats.length}>
              <FileDown className="h-4 w-4 mr-2" />Exporter (CSV)
            </Button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mt-4">
            {/* Filtre texte Agence */}
            <div>
              <Label htmlFor="filter-agence">Agence en charge</Label>
              <Input
                id="filter-agence"
                placeholder="Tapez pour filtrer..."
                value={filterAgence}
                onChange={e => setFilterAgence(e.target.value)}
              />
            </div>

            {/* Filtre texte Chef */}
            <div>
              <Label htmlFor="filter-chef">Chef d'Agence</Label>
              <Input
                id="filter-chef"
                placeholder="Tapez pour filtrer..."
                value={filterChef}
                onChange={e => setFilterChef(e.target.value)}
              />
            </div>

            {/* Sélecteur de période */}
            <div>
              <Label htmlFor="date-filter">Période</Label>
              <Select value={dateFilterOption} onValueChange={setDateFilterOption}>
                <SelectTrigger id="date-filter">
                  <SelectValue placeholder="Choisissez une période" />
                </SelectTrigger>
                <SelectContent>
                  {PERIOD_OPTIONS.map(opt => (
                    <SelectItem key={opt.value} value={opt.value}>
                      {opt.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              {showCalendar && (
                <Popover>
                  <PopoverTrigger asChild>
                    <Button variant="outline" className="w-full mt-2 justify-start text-left">
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {displayDateRange || 'Choisir…'}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="start">
                    <Calendar
                      mode="range"
                      selected={{ from: dateRange.start, to: dateRange.end }}
                      onSelect={range => {
                        if (range?.from && range?.to) setDateRange({ start: range.from, end: range.to });
                      }}
                      initialFocus
                    />
                  </PopoverContent>
                </Popover>
              )}
            </div>
          </div>
        </CardHeader>

        <CardContent>
          {isLoading ? (
            <div className="flex justify-center items-center h-64">
              <Loader2 className="h-12 w-12 animate-spin text-primary" />
            </div>
          ) : (
            <Table>
              <TableCaption>
                État du planning {displayDateRange}
                {filterAgence && ` • Agence: "${filterAgence}"`}
                {filterChef   && ` • Chef: "${filterChef}"`}
              </TableCaption>
              <TableHeader>
                <TableRow>
                  <TableHead>Agence</TableHead>
                  <TableHead>Code PDV</TableHead>
                  <TableHead>Chef</TableHead>
                  <TableHead className="text-center">Terminaux</TableHead>
                  <TableHead className="text-center">Jours</TableHead>
                  <TableHead className="text-center">À planifier</TableHead>
                  <TableHead className="text-center">Planifiées</TableHead>
                  <TableHead className="text-center">Taux</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredStats.length ? (
                  filteredStats.map((stat, idx) => (
                    <motion.tr
                      key={stat.id || idx}
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      transition={{ delay: idx * 0.05 }}
                      className={stat.rate < 90 ? 'bg-red-50 dark:bg-red-900/30' : ''}
                    >
                      <TableCell className="font-medium">{stat.agenceNom}</TableCell>
                      <TableCell>{stat.codePDV || 'N/A'}</TableCell>
                      <TableCell>{stat.chefNom}</TableCell>
                      <TableCell className="text-center">{stat.nTer}</TableCell>
                      <TableCell className="text-center">{stat.nJours}</TableCell>
                      <TableCell className="text-center">{stat.toPlan}</TableCell>
                      <TableCell className="text-center">{stat.planned}</TableCell>
                      <TableCell
                        className={`text-center font-semibold ${
                          stat.rate >= 90
                            ? 'text-green-600 dark:text-green-400'
                            : 'text-red-600 dark:text-red-400'
                        }`}
                      >
                        {stat.rate}%
                      </TableCell>
                    </motion.tr>
                  ))
                ) : (
                  <TableRow>
                    <TableCell colSpan={8} className="text-center text-muted-foreground py-8">
                      Aucune donnée pour ces filtres.
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>

      {/* --- Deuxième carte : calendrier --- */}
      <Card className="shadow-xl glassmorphism">
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle className="text-2xl font-semibold text-primary flex items-center">
              <CalendarIcon className="mr-2 h-6 w-6" />
              Vue Calendrier du Planning
            </CardTitle>
          </div>
          <CardDescription>
            Planning du mois de{' '}
            {isValid(dateRange.start)
              ? format(dateRange.start, 'MMMM yyyy', { locale: fr })
              : ''}
          </CardDescription>
        </CardHeader>
        <CardContent className="overflow-x-auto">
          {isLoading ? (
            <div className="flex justify-center items-center h-64">
              <Loader2 className="h-12 w-12 animate-spin text-primary" />
            </div>
          ) : (
            <>
              {/* Jours de la semaine */}
              <div className="grid grid-cols-7 gap-1 text-center font-medium text-muted-foreground mb-2">
                {['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim'].map(d => (
                  <div key={d}>{d}</div>
                ))}
              </div>
              {/* Cases vides + jours */}
              <div className="grid grid-cols-7 gap-1">
                {emptyStartCells.map((_, i) => (
                  <div key={i} className="border rounded-md p-1 min-h-[100px] bg-muted/10" />
                ))}
                {daysToDisplay.map(day => {
                  const inRange = isWithinInterval(day, { start: dateRange.start, end: dateRange.end });
                  const classes = cn(
                    'border rounded-md p-1 min-h-[100px] space-y-0.5',
                    inRange
                      ? 'bg-background/50 dark:bg-background/30'
                      : 'bg-muted/20 dark:bg-muted/40 opacity-60'
                  );
                  return (
                    <div key={day.toString()} className={classes}>
                      <div
                        className={`font-semibold text-sm ${
                          isSameDay(day, new Date())
                            ? 'text-primary font-bold'
                            : 'text-muted-foreground'
                        }`}
                      >
                        {format(day, 'd')}
                      </div>
                      {inRange && (
                        <div className="space-y-0.5 text-xs max-h-[80px] overflow-y-auto custom-scrollbar-xs">
                          {agences.map(agence => {
                            const nTer = parseInt(agence.nbreTerminaux) || 0;
                            const events = getPlanningForDayAndAgence(day, agence.nom);
                            const count = new Set(events.map(e => e.guichetiereId)).size;
                            let bg = 'bg-gray-200 dark:bg-gray-700';
                            
                            // Mettre en évidence le jour si c'est exactement la date filtrée (pour 'today'/'yesterday')
                            const isExactFilteredDate = (
                              isSameDay(day, dateRange.start) && 
                              isSameDay(dateRange.start, dateRange.end) && 
                              ['today', 'yesterday'].includes(dateFilterOption)
                            );
                            
                            if (nTer > 0) {
                              if (count === 0) bg = 'bg-red-200 dark:bg-red-800';
                              else if (count < nTer) bg = 'bg-yellow-200 dark:bg-yellow-700';
                              else bg = 'bg-green-200 dark:bg-green-700';
                            } else if (count > 0) {
                              bg = 'bg-green-200 dark:bg-green-700';
                            }
                            
                            // Ajouter une bordure pour les dates spécifiques (aujourd'hui/hier)
                            const extraClasses = isExactFilteredDate ? 'ring-2 ring-primary font-bold' : '';
                            
                            return (
                              <div 
                                key={agence.id} 
                                onClick={() => handleDayClick(day, agence)}
                                className={cn(
                                  'p-0.5 rounded text-[10px] leading-tight cursor-pointer hover:ring-1 hover:ring-primary',
                                  bg,
                                  'text-gray-800 dark:text-gray-100',
                                  extraClasses
                                )}
                              >
                                {agence.nom}: {count}
                              </div>
                            );
                          })}
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            </>
          )}
        </CardContent>
      </Card>

      {/* --- Modal détails --- */}
      {selectedModalData && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50" onClick={closeModal}>
          <motion.div
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            onClick={e => e.stopPropagation()}
            className="bg-card p-6 rounded-lg shadow-xl max-w-md w-full"
          >
            <h3 className="text-xl font-semibold text-primary mb-2">
              Détails – {selectedModalData.agence.nom}
            </h3>
            <p className="text-muted-foreground mb-4">
              {format(selectedModalData.date, 'eeee dd MMMM yyyy', { locale: fr })}
            </p>
            {(() => {
              const list = getGuichetieresForDayAndAgence(
                selectedModalData.date,
                selectedModalData.agence.nom
              );
              return list.length ? (
                <ul className="space-y-2 max-h-60 overflow-y-auto custom-scrollbar">
                  {list.map(g => (
                    <li key={g.id} className="p-2 bg-muted/50 rounded-md text-sm">
                      <div className="flex items-center">
                        {g.photo_url ? (
                          <img
                            src={g.photo_url}
                            alt={`${g.prenom}`}
                            className="h-8 w-8 rounded-full mr-2 object-cover"
                          />
                        ) : (
                          <div className="h-8 w-8 rounded-full mr-2 bg-gray-300 flex items-center justify-center text-xs text-gray-600">
                            {g.prenom?.charAt(0)}{g.nom?.charAt(0)}
                          </div>
                        )}
                        <span>
                          {g.prenom} {g.nom} (Mat: {g.matricule})
                        </span>
                      </div>
                    </li>
                  ))}
                </ul>
              ) : (
                <p className="text-muted-foreground">
                  Aucune guichetière planifiée.
                </p>
              );
            })()}
            <Button onClick={closeModal} variant="outline" className="mt-6 w-full">
              Fermer
            </Button>
          </motion.div>
        </div>
      )}
    </motion.div>
  );
};

export default EtatPlanningGeneralPage;
